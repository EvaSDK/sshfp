#!/usr/bin/python

# dane is a tool to generate and verify HASTLS and TLSA records
# By Paul Wouters <paul@xelerance.com> and Christopher Olah <chris@xelerance.com>
# Copyright 2011 by Xelerance http://www.xelerance.com/
# License: GNU GENERAL PUBLIC LICENSE Version 2 or later
#
# https://datatracker.ietf.org/wg/dane/charter/
# https://datatracker.ietf.org/doc/draft-ietf-dane-protocol/ 

try:
	import sys
	import libdane
	try:
		import ldnsx
	except:
		import daneldnsx
	import argparse
except ImportError as e:
	module = str(e)[16:]
	print >> sys.stderr, "dane requires the python module " + module
	if module in ["argparse", "ipcalc", "ldns"]:
		print >> sys.stderr, "Fedora/CentOS: yum install " \
                   + {"argparse":"python-argparse", "ipcalc": "python-ipcalc", "ldns": "ldns-python"}
		print >> sys.stderr, "Debian/Ubuntu: apt-get install " \
                   + {"argparse":"python-argparse", "ipcalc": "python-ipcalc", "ldns": "python-ldns"}
		print >> sys.stderr, "openSUSE: zypper in " \
                   + {"argparse":"python-argparse", "ipcalc": "python-ipcalc", "ldns": "python-ldns"}
	sys.exit(1)


# create the parser
parser = argparse.ArgumentParser(description='Create TLS related DNS records for hosts or an entire zone. version 1.2.1')

# AXFR
parser.add_argument('-n', '--nameserver', metavar="nameserver", action='append', help='nameserver to query')
parser.add_argument('--axfr', action='store_true', help='use AXFR (all A/AAAA records will be scanned)')

# IETF status related, currently --draft is the default
parser.add_argument('--draft', action='store_true',help='output in draft private rrtype (65468/65469) format (default)')
parser.add_argument('--rfc', action='store_true',help='output in rfc (TLSA/HASTLS) rrtype format')

# TLSA related	
parser.add_argument('--tlsa', action='store_true',help='generate TLSA record (default:yes)')
parser.add_argument('--eecert', action='store_true',help='use EEcert for TLSA record (default)')
parser.add_argument('--cacert', action='store_true',help='use CAcert for TLSA record (not supported yet)')
parser.add_argument('--pubkey', action='store_true',help='use pubkey for TLSA record (not supported yet)')
parser.add_argument('--txt', action='store_true',help='generate Kaminsky style TXT record (not supported yet)')

parser.add_argument('--sha256', action='store_true',help='use SHA256 for the TLSA cert type')
parser.add_argument('--sha512', action='store_true',help='use SHA512 for the TLSA cert type')
parser.add_argument('--full', action='store_true',help='use full certificate for the TLSA cert type')

# allow non-dnssec answers
parser.add_argument('--insecure', action='store_true',help='allow use of non-dnssec answers to find SSL hosts')

# limit networking to ipv4 or ipv6 only
parser.add_argument('-4', dest='ipv4', action='store_true',help='use ipv4 networking only')
parser.add_argument('-6', dest='ipv6', action='store_true',help='use ipv6 networking only')
parser.add_argument('-q', '--quiet', action='store_true',help='suppress warnings and errors')
parser.add_argument('-v', '--version', action='store_true',help='show version and exit')

# finally, the host list
parser.add_argument('hosts', metavar="hostname", nargs='+')

args = parser.parse_args(sys.argv[1:])

if args.version:
	sys.exit("dane: version 1.2.2")
if not args.rfc:
	args.draft = True

if args.cacert:
	sys.exit("TLSA CAcert type record not yet supported")
if args.pubkey:
	sys.exit("TLSA Pubkey type record not yet supported")

if args.sha512:
	reftype=2
elif args.full:
	reftype=0
else:
	reftype=1

if args.quiet:
	libdane.quiet = True

if args.tlsa:
	args.eecert = True

if args.insecure:
	libdane.secure = False

if args.ipv4 and not args.ipv6:
	libdane.transport = "ipv4"
if args.ipv6 and not args.ipv4:
	libdane.transport = "ipv6"

# filter the non-options arguments for an "@argument" and convert it for the axfr option.
filterHost= []
if not args.nameserver:
	args.nameserver = []
for host in args.hosts:
	if host[0] == "@":
		args.nameserver.append(host[1:])
		args.hosts.remove(host)
		args.axfr=True
	
if args.rfc and args.draft:
	libdane.fmt = "both"
elif args.rfc:
	libdane.fmt = "rfc"
else:
	libdane.fmt = "draft"

if not args.hosts:
	sys.exit("Host are needed.")
#	main("--help")

for host in args.hosts:
	if host[-1] != ".":
		host += "."
if not args.axfr:
	for host in args.hosts:
		print libdane.create_tlsa(host,1,reftype)
if args.axfr:
	# Try and AXFR it
	if len(args.nameserver) == 0:
		sys.exit("nameserver needed. syntax: -n nameserver")
	resolver = ldnsx.resolver(args.nameserver[0], dnssec=True)
	for host in args.hosts:
		ipv4 = []
		ipv6 = []
		for rr in resolver.AXFR(host):
			if rr.rr_type() == "A"    and rr.owner() not in ipv4:
				ipv4.append(rr.owner())
			if rr.rr_type() == "AAAA" and rr.owner() not in ipv6:
				ipv6.append(rr.owner())
		if transport != "ipv6":
			for host in ipv4:
				print libdane.create_tlsa(host,1,reftype)
		if transport != "ipv4":
			for host in ipv6:
				print libdane.create_tlsa(host,1,reftype)


